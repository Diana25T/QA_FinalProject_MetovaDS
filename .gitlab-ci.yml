# .gitlab-ci.yml
# Используем образ Python для большинства этапов
image: python:3.11

# Переменные, которые будут использоваться в пайплайне
variables:
  BASE_URL: $BASE_URL
  TANDOOR_TOKEN: $TANDOOR_TOKEN
  TANDOOR_USERNAME: $TANDOOR_USERNAME
  TANDOOR_PASSWORD: $TANDOOR_PASSWORD
  POSTGRES_PASSWORD: $POSTGRES_PASSWORD
  SECRET_KEY: $SECRET_KEY

  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  SELENIUM_REMOTE_URL: "http://selenium__standalone-chrome:4444/wd/hub"  # Для использования services
  CI: "true"  # Обязательно установите это для фикстуры
  DOCKER_COMPOSE_VERSION: "1.29.2"

# Кэширование зависимостей Python для ускорения сборок
cache:
  paths:
    - .cache/pip
    - venv/
    - .wdm/

#Сервис Docker-in-Docker для запуска контейнеров
services:
  - docker:dind

# Определяем этапы выполнения пайплайна
stages:
  - prepare
  - deploy_app # Этап запуска приложения
  - test_api
  - test_ui
  - report
  - cleanup  # Этап очистки
  - deploy

# Этап 1: Подготовка зависимостей и окружения
prepare_dependencies:
  stage: prepare
  script:
    # Устанавливаем Java (требуется для Allure)
    - apt-get update
    - apt-get install -y default-jre-headless wget unzip curl gnupg

     # Устанавливаем Docker клиент
    - echo "Установка Docker клиента..."
    - apt-get install -y ca-certificates curl gnupg lsb-release
    - mkdir -p /etc/apt/keyrings
    - curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    - echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list
    - apt-get update
    - apt-get install -y docker-ce-cli

    # Устанавливаем Docker Compose
    - echo "Установка Docker Compose..."
    - curl -L "https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    - chmod +x /usr/local/bin/docker-compose
    - docker-compose --version

    # Создаем виртуальное окружение Python
    - python -m venv venv
    - source venv/bin/activate

    # Обновляем pip и устанавливаем зависимости
    - pip install --upgrade pip
    - pip install --cache-dir=$PIP_CACHE_DIR -r requirements.txt
    - pip install pytest pytest-html allure-pytest requests selenium webdriver-manager


    # Устанавливаем Allure командной строки
    - wget -q "https://github.com/allure-framework/allure2/releases/download/2.24.1/allure-2.24.1.tgz"
    - tar -xzf allure-2.24.1.tgz -C /opt/
    - ln -sf /opt/allure-2.24.1/bin/allure /usr/local/bin/allure
    - allure --version

    # Проверяем что Java установлена
    - java --version

  artifacts:
    paths:
      - venv/
      - /opt/allure-2.24.1/
    expire_in: 1 hour
  rules:
    - if: '$CI_MERGE_REQUEST_ID'
    - if: '$CI_COMMIT_BRANCH == "main"'

# Этап 2:  Запуск приложения в Docker
deploy_application:
  stage: deploy_app
  image: docker:latest
  services:
    - docker:dind
  needs:
    - prepare_dependencies
  variables:
    POSTGRES_PASSWORD: $POSTGRES_PASSWORD
    SECRET_KEY: $SECRET_KEY
  script:
    - echo "=== ЗАПУСК ПРИЛОЖЕНИЯ В DOCKER ==="

    # Устанавливаем Docker Compose (в docker:latest его нет)
    - apk add --no-cache py3-pip docker-compose curl  #  в docker:latest используется apk, не apt-get!
    - docker-compose --version
    - curl --version

    # Настраиваем Docker
    - export DOCKER_HOST="tcp://docker:2375"
    - export DOCKER_TLS_CERTDIR=""

    # Проверяем связь
    - docker info || echo "Предупреждение:не удалось подключиться к Docker daemon"

    # Проверяем связь с Docker daemon
    - docker info || echo "Не удалось подключиться к Docker daemon"

    # Очищаем всё перед запуском
    - docker-compose down -v --remove-orphans 2>/dev/null || true
    - docker network prune -f 2>/dev/null || true

     # СОЗДАЕМ .env:
    - |
      cat > .env << EOF
      # Django settings
      SECRET_KEY=${SECRET_KEY}
      DEBUG=1
      ALLOWED_HOSTS=*
      CSRF_TRUSTED_ORIGINS=http://localhost,http://web_recipes
      
      # Database settings
      DB_ENGINE=django.db.backends.postgresql
      POSTGRES_HOST=db_recipes
      POSTGRES_PORT=5432
      POSTGRES_USER=djangodb
      POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      POSTGRES_DB=djangodb
      EOF

    - echo "2. Содержимое .env файла:"
    - cat .env

    # Проверка пароля
    - echo "3. Проверка пароля:"
    - echo "Длина переменной POSTGRES_PASSWORD:${#POSTGRES_PASSWORD}"
    - echo "Первые 2 символа:${POSTGRES_PASSWORD:0:2}..."
    - |
      if [ -z "$POSTGRES_PASSWORD" ]; then
      echo "  ВНИМАНИЕ: POSTGRES_PASSWORD ПУСТАЯ!"
      else
      echo "  Пароль установлен (длина: ${#POSTGRES_PASSWORD} символов)"
      fi

    # Проверяем невидимые символы
    - echo "5. Проверка на невидимые символы (hex dump):"
    - echo "GitLab переменная:" && echo -n "${POSTGRES_PASSWORD}" | xxd
    - echo "Первые 10 символов пароля:${POSTGRES_PASSWORD:0:10}..."

    # Проверяем что файл создан (без паролей)
    - echo "Создан .env файл:"
    - grep -v "PASSWORD\|SECRET_KEY" .env

    # Запускаем приложение
    - echo "Запускаем docker-compose up..."
    - docker-compose up -d

    # После docker-compose up -d
    - echo "=== ДИАГНОСТИКА ПРИЛОЖЕНИЯ ==="
    - sleep 45  # Даем больше времени на запуск

    - echo "1. Проверка изнутри Docker сети:"
    - docker run --network qa_finalproject_metova_default --rm curlimages/curl curl -s -o /dev/null -w "Статус:%{http_code}\n" http://web_recipes:80

    - echo "2. Проверка API:"
    - docker run --network qa_finalproject_metova_default --rm curlimages/curl curl -s -o /dev/null -w "API статус:%{http_code}\n" http://web_recipes:80/api/

    - echo "3. Логи приложения:"
    - docker-compose logs web_recipes --tail=30

    - echo "4. Проверка доступности для тестов:"
    - echo "Теперь тесты должны использовать http://web_recipes:80 вместо localhost"

    # Проверка подключения к базе данных
    - echo "Проверяем подключение к базе данных..."
    - |
      MAX_RETRIES=30
      DB_CONNECTED=false

      for i in $(seq 1 $MAX_RETRIES); do
        echo "Попытка $i/$MAX_RETRIES: Проверка подключения к БД..."

        if docker-compose exec -T db_recipes psql -U djangodb -d djangodb -c "SELECT 1;" 2>/dev/null; then
          echo " Подключение к базе данных успешно"
          DB_CONNECTED=true
          break
        fi

        sleep 2
      done

      if [ "$DB_CONNECTED" = "false" ]; then
        echo " Не удалось подключиться к базе данных за $MAX_RETRIES попыток"
        echo "Логи базы данных:"
        docker-compose logs db_recipes
        exit 1
      fi

     # Ждем запуска приложения
    - echo "Ожидание запуска приложения (макс 3 минуты)..."
    - |
      for i in $(seq 1 36); do
        if curl -s -f http://localhost:80 > /dev/null 2>&1; then
          echo " Приложение запущено после $i попыток!"
          break
        fi
        echo "Попытка $i/36: ждем 5 секунд..."
        sleep 5
      
        # Каждые 30 секунд показываем логи
        if [ $((i % 6)) -eq 0 ]; then
          echo "--- Текущие логи ---"
          docker-compose logs --tail=5
          echo "-------------------"
        fi
      done
      
      if [ $i -eq 60 ]; then
        echo "✗ Таймаут! Приложение не запустилось за 5 минут"
        echo "--- Полные логи ---"
        docker-compose logs
        echo "--- Проверка контейнеров ---"
        docker-compose ps
        echo "--- Проверка сети ---"
        docker network ls
        echo "-----------------"
        exit 1
      fi

    # Проверка сети и контейнеров
    - echo "Проверка сети и контейнеров..."
    - docker network ls
    - docker-compose ps -a
    - echo "Логи базы данных:"
    - docker-compose logs db_recipes --tail=10

    # Проверяем статус
    - echo "Статус контейнеров:"
    - docker-compose ps
    - echo "Проверка доступности приложения:"
    - curl -s -o /dev/null -w "HTTP статус:%{http_code}\n" --max-time 5 http://localhost:80 || echo "Запрос не удался (таймаут 5 сек)"

    - echo "=== Подробная диагностика ==="

    # 1. Проверяем сеть
    - echo "1. Проверка сети:"
    - |
      docker network inspect qa_finalproject_metova_default --format='{{json .Containers}}' | jq -r 'to_entries[] | "  \(.key): \(.value.Name) - IP: \(.value.IPv4Address)"' 2>/dev/null || echo "  (jq не установлен, пропускаем)"

    # 2. Проверяем, что контейнеры общаются
    - echo "2. Проверка связи между контейнерами:"
    - |
      docker exec qa_finalproject_metova-web_recipes-1 sh -c "ping -c 1 db_recipes > /dev/null && echo '  ✓ Web может связаться с БД' || echo '  ✗ Web НЕ может связаться с БД'"

    # 3. Проверяем порты внутри контейнера web
    - echo "3. Проверка портов в контейнере web:"
    - |
      docker exec qa_finalproject_metova-web_recipes-1 sh -c "netstat -tlnp 2>/dev/null | grep :80 || ss -tlnp 2>/dev/null | grep :80 || echo '  Порт 80 не слушает внутри контейнера'"

    # 4. Проверяем логи веб-приложения
    - echo "4. Логи веб-приложения:"
    - docker-compose logs web_recipes --tail=10

    # 5. Проверяем nginx/gunicorn (если используется)
    - echo "5. Проверка процессов в веб-контейнере:"
    - |
      docker exec qa_finalproject_metova-web_recipes-1 ps aux | grep -E "nginx|gunicorn|python|django" | head -5

    # 6. Альтернативная проверка доступности
    - echo "6. Альтернативные проверки:"
    - |
      # Проверяем изнутри контейнера
      echo "  - Проверка изнутри контейнера web:"
      docker exec qa_finalproject_metova-web_recipes-1 sh -c "curl -s -o /dev/null -w '  Внутренний статус: %{http_code}\n' http://localhost:80 || echo '  Внутренний запрос не удался'"

      # Проверяем порт снаружи
      echo "  - Проверка порта 80 снаружи:"
      if nc -z -w 2 localhost 80; then
        echo "  ✓ Порт 80 открыт"
        # Пробуем получить заголовки
        echo "  - Заголовки ответа:"
        curl -I --max-time 5 http://localhost:80 2>&1 | head -5 || echo "  Не удалось получить заголовки"
      else
        echo "  ✗ Порт 80 закрыт"
      fi

    # Проверяем логи
    - echo "Логи db_recipes:"
    - docker-compose logs db_recipes --tail=20

    # Проверяем доступность порта 80
    - echo "Проверка порта 80:"
    - timeout 10 bash -c "until nc -z localhost 80; do sleep 1; echo 'Ждем порт 80...'; done" || echo "Порт 80 не открыт"

    # Проверяем что nginx отвечает
    - curl -I http://localhost:80 || echo "nginx не отвечает"
    - echo "=== ПРОВЕРКА ДОСТУПНОСТИ ИЗНУТРИ DOCKER ==="
    - docker run --network qa_finalproject_metova_default --rm curlimages/curl curl -s -o /dev/null -w "%{http_code}" http://web_recipes:80 && echo "✓ Доступен изнутри Docker сети" || echo "✗ Не доступен изнутри Docker сети"

    - echo "=== БЫСТРЫЙ ТЕСТ API ==="
    - docker run --network qa_finalproject_metova_default --rm curlimages/curl curl -s -v "http://web_recipes:80/api/recipe/" 2>&1 | grep -E "HTTP|<title>|error" | head -10

# Этап 2: Запуск API тестов
test_api:
  stage: test_api
  needs:
    - job: prepare_dependencies
      artifacts: true
    - job: deploy_application  # Зависимость от запущенного приложения
      artifacts: false
  script:
    # Активируем виртуальное окружение
    - source venv/bin/activate

    # Выводим информацию о переменных
    - echo "Запускаем API тесты на ЛОКАЛЬНОМ приложении $BASE_URL"
    - echo "Пользователь:$TANDOOR_USERNAME"
    - echo "Bearer Token (первые 10 символов):${TANDOOR_TOKEN:0:10}..."
    - echo "Приложение запущено в Docker контейнере"

    #  Проверяем доступность приложения перед тестами
    - echo "Проверка доступности приложения..."
    - curl -s -f http://localhost:80 > /dev/null && echo "✓ Приложение доступно" || echo "✗ Приложение недоступно"

    # Запускаем API тесты с маркировкой 'api' и создаем JUnit отчет
    - pytest tests/ -m api -v --alluredir=allure-results-api --junitxml=junit-api.xml

  artifacts:
    when: always
    expire_in: 1 week
    paths:
      - allure-results-api/
      - junit-api.xml
    reports:
      junit: junit-api.xml
  rules:
    - if: '$CI_MERGE_REQUEST_ID'
    - if: '$CI_COMMIT_BRANCH == "main"'

# Этап 4: Запуск UI тестов
test_ui:
  stage: test_ui
  image: python:3.11  # Используем Python образ, а не Selenium
  services:
    - name: selenium/standalone-chrome:latest
      alias: selenium-standalone-chrome
  variables:
    # Переменная для вашей фикстуры
    SELENIUM_REMOTE_URL: "http://selenium-standalone-chrome:4444/wd/hub"
    CI: "true"
  needs:
    - prepare_dependencies
    - deploy_application  # Зависимость от запущенного приложения
  before_script:
    # Активируем виртуальное окружение
    - source venv/bin/activate
    # Ждем запуска Selenium сервиса
    - sleep 10  # Даем время Selenium запуститься
    # Проверяем доступность Selenium
    - curl -s http://selenium-standalone-chrome:4444/wd/hub/status|grep '"ready":true' || echo "Selenium не готов"

    #  Проверяем доступность приложения
    - echo "Проверка доступности приложения для UI тестов..."
    - |
       for i in {1..10}; do
        if curl -s -f http://localhost:80 > /dev/null; then
          echo " Приложение доступно после $i попыток"
          break
        fi
        echo " Попытка $i: Приложение недоступно"
        sleep 3
        done
  script:
    # Выводим информацию о локальном тестировании
    - echo "Запускаем UI тесты на ЛОКАЛЬНОМ приложении $BASE_URL"
    - echo "Используем Selenium по адресу $SELENIUM_REMOTE_URL"

    # Запускаем UI тесты с локальным URL
    - pytest tests/ -m ui -v --alluredir=allure-results-ui --junitxml=junit-ui.xml --base-url=$BASE_URL
  artifacts:
    when: always
    paths:
      - allure-results-ui/
      - screenshots-output/
      - junit-ui.xml
    reports:
      junit: junit-ui.xml
  rules:
    - if: '$CI_MERGE_REQUEST_ID'
    - if: '$CI_COMMIT_BRANCH == "main"'

# Этап 5: Генерация отчета Allure
generate_allure_report:
  stage: report
  needs:
    - job: test_api
      artifacts: true
    - job: test_ui
      artifacts: true
  script:
    - echo "Генерация объединенного Allure отчета..."

    # Проверяем что Java установлена
    - java --version
    - allure --version

    # Объединяем результаты API и UI тестов
    - mkdir -p allure-results-combined

    # Копируем результаты API тестов
    - if [ -d "allure-results-api" ]; then
        echo "Копируем результаты API тестов..."
        cp -r allure-results-api/* allure-results-combined/ 2>/dev/null || true
      else
        echo "Директория allure-results-api не найдена"
      fi

    # Копируем результаты UI тестов
    - if [ -d "allure-results-ui" ]; then
        echo "Копируем результаты UI тестов..."
        cp -r allure-results-ui/* allure-results-combined/ 2>/dev/null || true
      else
        echo "Директория allure-results-ui не найдена"
      fi

    # Генерируем HTML отчет
    - echo "Содержимое allure-results-combined:"
    - find allure-results-combined -type f 2>/dev/null | head -5 || echo "Директория пуста"

    - allure generate allure-results-combined --clean -o public

    # Проверяем что отчет создан
    - echo "Содержимое public:"
    - ls -la public/

  artifacts:
    paths:
      - public/
    expire_in: 30 days
  rules:
    - if: '$CI_MERGE_REQUEST_ID'
    - if: '$CI_COMMIT_BRANCH == "main"'

# Этап 6: остановка контейнеров
cleanup:
  stage: cleanup
  needs:
    - test_api
    - test_ui
  script:
    - echo "Остановка Docker контейнеров..."
    - docker-compose down -v || true
    - echo "Очистка Docker системы..."
    - docker system prune -f || true
  when: always  # Всегда выполняем очистку

# Этап 6: Публикация отчета на GitLab Pages
pages:
  stage: deploy
  dependencies:
    - generate_allure_report
  script:
    - echo "Публикация Allure отчета на GitLab Pages..."
    - echo "Отчет будет доступен по адресу:https://$CI_PROJECT_NAMESPACE.gitlab.io/$CI_PROJECT_NAME"
  artifacts:
    paths:
      - public
  only:
    - main  # Публикуем отчет только для ветки main